## Pseudocode: crates/tx/src/soroban/protocol/p24.rs

"Protocol 24 Soroban host implementation."
"This module provides Soroban execution for protocol versions 20-24."
"It uses soroban-env-host-p24 which is pinned to the exact git revision"
"used by stellar-core for protocol 24."

### LedgerSnapshotAdapter.get

"Adapter that provides snapshot access to our ledger state for Soroban."

```
function snapshot_get(key_p24):
  key = convert_ledger_key_from_p24(key_p24)
  GUARD key is null → InternalError

  "For ContractData and ContractCode, check TTL first."
  "If TTL has expired, the entry is considered to be in the hot archive"
  "and not accessible (unless being explicitly restored)."
  live_until = get_entry_ttl(state, key, current_ledger)

  if key is Account:
    entry = state.get_account(key.account_id)
    wrap as LedgerEntry(Account)

  else if key is Trustline:
    entry = state.get_trustline_by_trustline_asset(key.account_id, key.asset)
    wrap as LedgerEntry(Trustline)

  else if key is ContractData:
    if live_until exists AND live_until < current_ledger:
      "Entry is archived, not in live bucket list"
      → null
    entry = state.get_contract_data(key.contract, key.key, key.durability)
    wrap as LedgerEntry(ContractData)

  else if key is ContractCode:
    if live_until exists AND live_until < current_ledger:
      "Entry is archived, not in live bucket list"
      → null
    entry = state.get_contract_code(key.hash)
    wrap as LedgerEntry(ContractCode)

  else if key is Ttl:
    entry = state.get_ttl(key.key_hash)
    wrap as LedgerEntry(Ttl)

  else:
    → null

  if entry exists:
    converted = convert_ledger_entry_to_p24(entry)
    GUARD converted is null → InternalError
    → (converted, live_until)
  else:
    → null
```

**Calls:** [get_entry_ttl](#helper-get_entry_ttl), [convert_ledger_key_from_p24](#helper-convert_ledger_key_from_p24), [convert_ledger_entry_to_p24](#helper-convert_ledger_entry_to_p24)

---

### Helper: get_entry_ttl

"Uses get_ttl_at_ledger_start() to return the TTL value from the bucket"
"list snapshot at ledger start. This matches stellar-core behavior for"
"parallel Soroban execution (V1 phases): transactions in different clusters"
"should NOT see each other's TTL changes."

```
function get_entry_ttl(state, key, current_ledger):
  if key is ContractData or ContractCode:
    key_hash = compute_key_hash(key)
    ttl = state.get_ttl_at_ledger_start(key_hash)
    → ttl
  else:
    → null
```

**Calls:** [compute_key_hash](#helper-compute_key_hash)

---

### Helper: compute_key_hash

```
function compute_key_hash(key):
  bytes = serialize_xdr(key)
  → SHA256(bytes)
```

---

### Helper: get_entry_for_restoration

"Get an entry for restoration from the hot archive or live BucketList."
"This is used when an entry is being explicitly restored - we need to fetch"
"the entry even though its TTL has expired or doesn't exist."

```
function get_entry_for_restoration(state, key, current_ledger):
  if key is ContractData or ContractCode:
    key_hash = compute_key_hash(key)
    live_until = state.get_ttl(key_hash)?.live_until_ledger_seq
  else:
    live_until = null

  "Fetch entry from state WITHOUT filtering by TTL"
  if key is ContractData:
    entry = state.get_contract_data(key.contract, key.key, key.durability)
    wrap as LedgerEntry(ContractData)
  else if key is ContractCode:
    entry = state.get_contract_code(key.hash)
    wrap as LedgerEntry(ContractCode)
  else:
    "Restoration only applies to ContractData and ContractCode"
    → (null, null)

  → (entry, live_until)
```

**Calls:** [compute_key_hash](#helper-compute_key_hash)

---

### Helper: convert_ledger_key_to_p24

```
function convert_ledger_key_to_p24(key):
  bytes = serialize_xdr(key)         NOTE: using current XDR
  → deserialize_xdr_p24(bytes)       NOTE: into p24 XDR
```

---

### Helper: convert_ledger_key_from_p24

```
function convert_ledger_key_from_p24(key_p24):
  bytes = serialize_xdr_p24(key_p24)
  → deserialize_xdr(bytes)           NOTE: into current XDR
```

---

### Helper: convert_ledger_entry_to_p24

```
function convert_ledger_entry_to_p24(entry):
  bytes = serialize_xdr(entry)
  → deserialize_xdr_p24(bytes)
```

---

### invoke_host_function

"Invoke a host function using the protocol 24 soroban-env-host."

```
function invoke_host_function(host_function, auth_entries, source,
                              state, context, soroban_data, soroban_config):

  --- Phase 1: Budget setup ---
  instruction_limit = soroban_config.tx_max_instructions * 2
  memory_limit = soroban_config.tx_max_memory_bytes * 2

  if soroban_config.has_valid_cost_params():
    cpu_cost_params = convert_contract_cost_params_to_p24(
                        soroban_config.cpu_cost_params)
    GUARD cpu_cost_params is null → InternalError
    mem_cost_params = convert_contract_cost_params_to_p24(
                        soroban_config.mem_cost_params)
    GUARD mem_cost_params is null → InternalError
    budget = Budget.try_from_configs(
      instruction_limit, memory_limit,
      cpu_cost_params, mem_cost_params)
  else:
    budget = Budget.default()

  --- Phase 2: Ledger info ---
  ledger_info = LedgerInfoP24 {
    protocol_version: context.protocol_version,
    sequence_number:  context.sequence,
    timestamp:        context.close_time,
    network_id:       context.network_id,
    base_reserve:     context.base_reserve,
    min_temp_entry_ttl:       soroban_config.min_temp_entry_ttl,
    min_persistent_entry_ttl: soroban_config.min_persistent_entry_ttl,
    max_entry_ttl:            soroban_config.max_entry_ttl,
  }

  --- Phase 3: PRNG seed ---
  if context.soroban_prng_seed exists:
    seed = context.soroban_prng_seed
  else:
    seed = SHA256(network_id || sequence_le || close_time_le)

  --- Phase 4: XDR encoding ---
  encoded_host_fn   = serialize_xdr(host_function)
  encoded_resources  = serialize_xdr(soroban_data.resources)
  encoded_source     = serialize_xdr(source)
  encoded_auth_entries = [serialize_xdr(e) for e in auth_entries]

  --- Phase 5: Extract archived entry indices ---
  "These indices point into the read_write footprint and indicate"
  "entries being restored"
  if soroban_data.ext is V1:
    restored_rw_entry_indices = ext.archived_soroban_entries
  else:
    restored_rw_entry_indices = []
  restored_indices_set = Set(restored_rw_entry_indices)

  --- Phase 6: Collect footprint entries ---
  snapshot = LedgerSnapshotAdapter(state, context.sequence)
  encoded_ledger_entries = []
  encoded_ttl_entries = []

  for each key in soroban_data.resources.footprint.read_only:
    key_p24 = convert_ledger_key_to_p24(key)
    (entry, live_until) = snapshot.get(key_p24)
    if entry exists:
      add_entry(key, entry, live_until)

  for each (idx, key) in soroban_data.resources.footprint.read_write:
    if idx in restored_indices_set:
      "Entry is being restored from archive - fetch WITHOUT TTL filtering"
      (entry, live_until) = get_entry_for_restoration(state, key, context.sequence)
      if entry exists:
        entry_p24 = convert_ledger_entry_to_p24(entry)
        GUARD entry_p24 is null → InternalError
        add_entry(key, entry_p24, live_until)
    else:
      "Normal entry - use standard TTL-filtered lookup"
      key_p24 = convert_ledger_key_to_p24(key)
      (entry, live_until) = snapshot.get(key_p24)
      if entry exists:
        add_entry(key, entry, live_until)

  --- Helper: add_entry (inline closure) ---
  function add_entry(key, entry, live_until):
    encoded_ledger_entries.append(serialize_xdr_p24(entry))

    needs_ttl = key is ContractData or ContractCode
    if live_until exists:
      key_hash = compute_key_hash(key)
      ttl_entry = TtlEntry(key_hash, live_until)
      encoded_ttl_entries.append(serialize_xdr_p24(ttl_entry))
    else if needs_ttl:
      "For archived entries being restored, provide a TTL at"
      "the current ledger. The host validates TTL >= current_ledger."
      key_hash = compute_key_hash(key)
      ttl_entry = TtlEntry(key_hash, current_ledger)
      encoded_ttl_entries.append(serialize_xdr_p24(ttl_entry))
    else:
      encoded_ttl_entries.append(empty_bytes)

  --- Phase 7: e2e_invoke ---
  diagnostic_events = []
  result = e2e_invoke::invoke_host_function(
    budget, enable_diagnostics=true,
    encoded_host_fn, encoded_resources,
    restored_rw_entry_indices, encoded_source,
    encoded_auth_entries, ledger_info,
    encoded_ledger_entries, encoded_ttl_entries,
    seed, diagnostic_events)

  --- Phase 8: Parse return value ---
  return_value = deserialize_xdr(result.encoded_invoke_result)

  --- Phase 9: Convert ledger changes ---
  "Include entries that:"
  "- Had their content modified"
  "- Are involved in rent calculations"
  "- Had their TTL actually extended (new > old)"
  "Note: stellar-core only includes TTL changes when TTL is extended,"
  "not just when ttl_change is present."
  ledger_changes = []
  for each change in result.ledger_changes:
    ttl_extended = change.ttl_change exists
                   AND change.ttl_change.new > change.ttl_change.old
    if change.has_new_value
       OR change.old_entry_size_bytes_for_rent > 0
       OR ttl_extended:
      key = deserialize_xdr(change.encoded_key)
      new_entry = deserialize_xdr(change.encoded_new_value) if present
      ttl_change = { old: ..., new: ... } if change.ttl_change present
      ledger_changes.append(LedgerEntryChange {
        key, new_entry, ttl_change,
        old_entry_size_bytes: change.old_entry_size_bytes_for_rent
      })

  --- Phase 10: Decode contract events ---
  "Only Contract and System events go into the success preimage hash"
  contract_events = []
  encoded_contract_events = []
  for each encoded_event in result.encoded_contract_events:
    encoded_contract_events.append(
      EncodedContractEvent(encoded_event, in_successful_call=true))
    event = deserialize_xdr(encoded_event)
    if event.type is Contract or System:
      contract_events.append(event)

  cpu_insns = budget.get_cpu_insns_consumed()
  mem_bytes = budget.get_mem_bytes_consumed()

  → InvokeHostFunctionOutput {
      return_value, ledger_changes,
      contract_events, encoded_contract_events,
      cpu_insns, mem_bytes,
      "P24 doesn't have auto-restore, so no live BL restorations"
      live_bucket_list_restores: []
    }
```

**Calls:** [get_entry_for_restoration](#helper-get_entry_for_restoration), [LedgerSnapshotAdapter.get](#ledgersnapshotadapterget), [convert_ledger_key_to_p24](#helper-convert_ledger_key_to_p24), [convert_ledger_entry_to_p24](#helper-convert_ledger_entry_to_p24), [compute_key_hash](#helper-compute_key_hash), `convert_host_error_p24_to_p25` REF: soroban/error::convert_host_error_p24_to_p25

---

## Summary

| Metric        | Source | Pseudocode |
|---------------|--------|------------|
| Lines (logic) | ~550   | ~190       |
| Functions     | 9      | 9          |
