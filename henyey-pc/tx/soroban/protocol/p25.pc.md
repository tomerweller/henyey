## Pseudocode: crates/tx/src/soroban/protocol/p25.rs

"Protocol 25 Soroban host implementation."
"This module provides Soroban execution for protocol version 25."
"It uses soroban-env-host-p25 which is pinned to the exact git revision"
"used by stellar-core for protocol 25."

NOTE: soroban-env-host v25.0.0 uses stellar-xdr 25.0.0 from crates.io,
while the workspace uses a git revision of stellar-xdr. Conversion between
the two happens via XDR serialization at the boundary.

---

### LedgerSnapshotAdapter.get_local

"Adapter that provides snapshot access to our ledger state for Soroban."
"IMPORTANT: This function filters out expired Soroban entries (ContractData,"
"ContractCode) to match stellar-core behavior. In stellar-core, entries with"
"expired TTL are not passed to the host during invoke_host_function."

```
function get_local(key):
  live_until = get_entry_ttl(state, key, current_ledger)

  if key is Account:
    entry = state.get_account(key.account_id)
    wrap as LedgerEntry(Account)

  else if key is Trustline:
    entry = state.get_trustline_by_trustline_asset(key.account_id, key.asset)
    wrap as LedgerEntry(Trustline)

  else if key is ContractData:
    "ContractData entries only accessible if TTL is valid"
    if live_until exists AND live_until >= current_ledger:
      entry = state.get_contract_data(key.contract, key.key, key.durability)
      wrap as LedgerEntry(ContractData)
    else:
      "Expired or no TTL — not passed to host"
      → null

  else if key is ContractCode:
    "Same as ContractData — require valid TTL"
    if live_until exists AND live_until >= current_ledger:
      entry = state.get_contract_code(key.hash)
      wrap as LedgerEntry(ContractCode)
    else:
      → null

  else if key is Ttl:
    entry = state.get_ttl(key.key_hash)
    wrap as LedgerEntry(Ttl)

  else:
    → null

  if entry exists:
    → (entry, live_until)
  else:
    → null
```

**Calls:** [get_entry_ttl](#helper-get_entry_ttl)

---

### LedgerSnapshotAdapter.get (SnapshotSource trait)

```
function snapshot_get(key_p25):
  local_key = convert_ledger_key_from_p25(key_p25)
  if local_key is null:
    → null

  live_until = get_entry_ttl(state, local_key, current_ledger)

  NOTE: Entry lookup logic is identical to get_local but with
  p25-typed keys. For ContractData/ContractCode, entries with
  expired or missing TTL are treated as archived and return null.

  entry = <lookup by key type, TTL-filtered>

  if entry exists:
    p25_entry = convert_ledger_entry_to_p25(entry)
    GUARD p25_entry is null → InternalError
    → (p25_entry, live_until)
  else:
    → null
```

**Calls:** [get_entry_ttl](#helper-get_entry_ttl), [convert_ledger_key_from_p25](#helper-convert_ledger_key_from_p25), [convert_ledger_entry_to_p25](#helper-convert_ledger_entry_to_p25)

---

### Helper: get_entry_ttl

"IMPORTANT: Uses get_ttl_at_ledger_start() to return the TTL value from"
"the bucket list snapshot at ledger start. This is critical for matching"
"stellar-core behavior in parallel Soroban execution (V1 phases):"
""
"- Transactions in different clusters of the same stage should NOT see"
"  each other's changes (including newly created TTL entries)"
"- Only entries that existed at ledger start should be passed to the host"
"- Entries created by earlier transactions in the same ledger are filtered out"

```
function get_entry_ttl(state, key, current_ledger):
  if key is ContractData or ContractCode:
    key_hash = compute_key_hash(key)
    "Use get_ttl_at_ledger_start() — NOT current TTL"
    ttl = state.get_ttl_at_ledger_start(key_hash)
    → ttl
  else:
    → null
```

**Calls:** [compute_key_hash](#helper-compute_key_hash)

---

### Helper: compute_key_hash

```
function compute_key_hash(key):
  bytes = serialize_xdr(key)
  → SHA256(bytes)
```

---

### Helper: convert_ledger_key_from_p25

```
function convert_ledger_key_from_p25(key_p25):
  bytes = serialize_xdr_p25(key_p25)
  → deserialize_xdr(bytes)           NOTE: into workspace XDR
```

---

### Helper: convert_ledger_entry_to_p25

```
function convert_ledger_entry_to_p25(entry):
  bytes = serialize_xdr(entry)        NOTE: workspace XDR
  → deserialize_xdr_p25(bytes)        NOTE: into p25 XDR
```

---

### Struct: RestorationInfo

```
struct RestorationInfo:
  entry: LedgerEntry          // the data/code entry being restored
  live_until: optional uint32
  live_bl_restore: optional LiveBucketListRestore
    // "If this is a live BL restore (entry exists with expired TTL),"
    // "contains the full restore info needed for RESTORED ledger entry changes."
```

---

### Helper: get_entry_for_restoration

"Get an entry for restoration from the hot archive or live BucketList."
"If the entry exists in the live BucketList with an expired TTL, this is a"
"live BL restore and we return the complete LiveBucketListRestore info"
"needed to emit RESTORED ledger entry changes."

```
function get_entry_for_restoration(state, key, current_ledger):
  --- Get TTL and build TTL entry ---
  if key is ContractData or ContractCode:
    key_hash = compute_key_hash(key)
    ttl = state.get_ttl(key_hash)
    if ttl exists:
      live_until = ttl.live_until_ledger_seq
      ttl_ledger_entry = LedgerEntry(Ttl, ttl)
      ttl_key = LedgerKey::Ttl(key_hash)
    else:
      live_until = null
      ttl_entry_opt = null
  else:
    → null   // "Restoration only applies to ContractData and ContractCode"

  --- Fetch entry WITHOUT TTL filtering ---
  if key is ContractData:
    entry = state.get_contract_data(key.contract, key.key, key.durability)
    wrap as LedgerEntry(ContractData)
  else if key is ContractCode:
    entry = state.get_contract_code(key.hash)
    wrap as LedgerEntry(ContractCode)

  if entry is null:
    → null

  --- Check for live BL restore ---
  "Entry exists AND TTL is expired"
  if live_until exists AND ttl_entry exists
     AND live_until < current_ledger:
    live_bl_restore = LiveBucketListRestore {
      key, entry, ttl_key, ttl_ledger_entry
    }
  else:
    live_bl_restore = null

  → RestorationInfo { entry, live_until, live_bl_restore }
```

**Calls:** [compute_key_hash](#helper-compute_key_hash)

---

### invoke_host_function

"Invoke a host function using the protocol 25 soroban-env-host."

```
function invoke_host_function(host_function, auth_entries, source,
                              state, context, soroban_data, soroban_config):

  --- Phase 1: Budget setup ---
  instruction_limit = soroban_config.tx_max_instructions * 2
  memory_limit = soroban_config.tx_max_memory_bytes * 2

  if soroban_config.has_valid_cost_params():
    cpu_params = convert_contract_cost_params_to_p25(
                   soroban_config.cpu_cost_params)
    GUARD cpu_params is null → InternalError
    mem_params = convert_contract_cost_params_to_p25(
                   soroban_config.mem_cost_params)
    GUARD mem_params is null → InternalError
    budget = Budget.try_from_configs(
      instruction_limit, memory_limit, cpu_params, mem_params)
  else:
    budget = Budget.default()

  --- Phase 2: Ledger info ---
  ledger_info = LedgerInfo {
    protocol_version: context.protocol_version,
    sequence_number:  context.sequence,
    timestamp:        context.close_time,
    network_id:       context.network_id,
    base_reserve:     context.base_reserve,
    min_temp_entry_ttl:       soroban_config.min_temp_entry_ttl,
    min_persistent_entry_ttl: soroban_config.min_persistent_entry_ttl,
    max_entry_ttl:            soroban_config.max_entry_ttl,
  }

  --- Phase 3: PRNG seed ---
  if context.soroban_prng_seed exists:
    seed = context.soroban_prng_seed
  else:
    seed = SHA256(network_id || sequence_le || close_time_le)

  --- Phase 4: XDR encoding ---
  encoded_host_fn    = serialize_xdr(host_function)
  encoded_resources  = serialize_xdr(soroban_data.resources)
  encoded_source     = serialize_xdr(source)
  encoded_auth_entries = [serialize_xdr(e) for e in auth_entries]

  --- Phase 5: Extract archived entry indices ---
  "These indices point into the read_write footprint and indicate"
  "entries being restored"
  if soroban_data.ext is V1:
    restored_rw_entry_indices = ext.archived_soroban_entries
  else:
    restored_rw_entry_indices = []
  restored_indices_set = Set(restored_rw_entry_indices)

  --- Phase 6: Collect footprint entries ---
  snapshot = LedgerSnapshotAdapter(state, context.sequence)
  encoded_ledger_entries = []
  encoded_ttl_entries = []

  --- Helper: add_entry (inline closure) ---
  function add_entry(key, entry, live_until):
    encoded_ledger_entries.append(serialize_xdr(entry))
    if live_until exists:
      key_hash = compute_key_hash(key)
      ttl_entry = TtlEntry(key_hash, live_until)
      encoded_ttl_entries.append(serialize_xdr(ttl_entry))
    else:
      encoded_ttl_entries.append(empty_bytes)

  --- Read-only footprint ---
  for each key in soroban_data.resources.footprint.read_only:
    (entry, live_until) = snapshot.get_local(key)
    if entry exists:
      add_entry(key, entry, live_until)

  --- Read-write footprint (with restoration handling) ---
  live_bl_restores = []

  for each (idx, key) in soroban_data.resources.footprint.read_write:
    if idx in restored_indices_set:
      "Entry is being restored - fetch without TTL filtering"
      restore_info = get_entry_for_restoration(state, key, context.sequence)
      if restore_info exists:
        add_entry(key, restore_info.entry, restore_info.live_until)
        if restore_info.live_bl_restore exists:
          live_bl_restores.append(restore_info.live_bl_restore)
    else:
      "Normal entry - use standard TTL-filtered lookup"
      (entry, live_until) = snapshot.get_local(key)
      if entry exists:
        add_entry(key, entry, live_until)

  --- Phase 7: e2e_invoke ---
  diagnostic_events = []
  result = e2e_invoke::invoke_host_function(
    budget, enable_diagnostics=true,
    encoded_host_fn, encoded_resources,
    restored_rw_entry_indices, encoded_source,
    encoded_auth_entries, ledger_info,
    encoded_ledger_entries, encoded_ttl_entries,
    seed, diagnostic_events)

  --- Phase 8: Parse return value ---
  return_value = deserialize_xdr(result.encoded_invoke_result)

  --- Phase 9: Convert ledger changes ---
  "Include entries that:"
  "- Had their content modified"
  "- Are involved in rent calculations"
  "- Had their TTL actually extended (new > old)"
  "Note: stellar-core only includes TTL changes when TTL is extended,"
  "not just when ttl_change is present."
  ledger_changes = []
  for each change in result.ledger_changes:
    ttl_extended = change.ttl_change exists
                   AND change.ttl_change.new > change.ttl_change.old
    if change.has_new_value
       OR change.old_entry_size_bytes_for_rent > 0
       OR ttl_extended:
      key = deserialize_xdr(change.encoded_key)
      new_entry = deserialize_xdr(change.encoded_new_value) if present
      ttl_change = { old: ..., new: ... } if present
      ledger_changes.append(LedgerEntryChange {
        key, new_entry, ttl_change,
        old_entry_size_bytes: change.old_entry_size_bytes_for_rent
      })

  --- Phase 10: Decode contract events ---
  "Only Contract and System events go into the success preimage hash"
  contract_events = []
  encoded_contract_events = []
  for each encoded_event in result.encoded_contract_events:
    encoded_contract_events.append(
      EncodedContractEvent(encoded_event, in_successful_call=true))
    event = deserialize_xdr(encoded_event)
    if event.type is Contract or System:
      contract_events.append(event)

  cpu_insns = budget.get_cpu_insns_consumed()
  mem_bytes = budget.get_mem_bytes_consumed()

  → InvokeHostFunctionOutput {
      return_value, ledger_changes,
      contract_events, encoded_contract_events,
      cpu_insns, mem_bytes,
      live_bucket_list_restores: live_bl_restores
    }
```

**Calls:** [get_entry_for_restoration](#helper-get_entry_for_restoration), [LedgerSnapshotAdapter.get_local](#ledgersnapshotadapterget_local), [compute_key_hash](#helper-compute_key_hash)

---

## Summary

| Metric        | Source | Pseudocode |
|---------------|--------|------------|
| Lines (logic) | ~820   | ~200       |
| Functions     | 10     | 10         |
