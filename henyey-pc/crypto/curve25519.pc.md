## Pseudocode: crypto/curve25519.rs

"Curve25519 ECDH key exchange for P2P overlay authentication."
"Ed25519 for signatures, Curve25519 for session key agreement (ephemeral)."
"During P2P handshake, peers generate random Curve25519 keys and sign them"
"with their long-lived Ed25519 keys."

### Curve25519Secret (struct)

```
STRUCT Curve25519Secret:
  inner: X25519 static secret (32 bytes, zeroized on drop)
```

### Curve25519Public (struct)

```
STRUCT Curve25519Public:
  inner: X25519 public key (32 bytes)
```

### Curve25519Secret.random

```
function Curve25519Secret.random() -> Curve25519Secret:
  bytes = 32 random bytes from CSPRNG
  -> Curve25519Secret from bytes
```

### Curve25519Secret.from_bytes

```
function Curve25519Secret.from_bytes(bytes: byte_array[32])
    -> Curve25519Secret:
  -> Curve25519Secret wrapping StaticSecret from bytes
```

### Curve25519Secret.to_bytes

```
function Curve25519Secret.to_bytes(self) -> byte_array[32]:
  -> self.inner as bytes
```

### Curve25519Secret.derive_public

```
function Curve25519Secret.derive_public(self) -> Curve25519Public:
  -> Curve25519Public from self.inner
```

### Curve25519Secret.diffie_hellman

```
function Curve25519Secret.diffie_hellman(self,
    remote_public: Curve25519Public) -> byte_array[32]:
  "Computes localSecret * remotePublic (scalar multiplication)."
  -> self.inner.diffie_hellman(remote_public.inner)
```

### Curve25519Secret.derive_shared_key

```
function Curve25519Secret.derive_shared_key(
    local_secret:  Curve25519Secret,
    local_public:  Curve25519Public,
    remote_public: Curve25519Public,
    local_first:   boolean) -> byte_array[32]:
  "Derives an HMAC-SHA256 key via ECDH + HKDF-extract."
  "Formula: HKDF_extract(shared_secret || publicA || publicB)"

  shared_secret = local_secret.diffie_hellman(remote_public)

  if local_first:
    public_a = local_public
    public_b = remote_public
  else:
    public_a = remote_public
    public_b = local_public

  buf = shared_secret || public_a.bytes || public_b.bytes
  -> hkdf_extract(buf)
```

**Calls**: [diffie_hellman](#curve25519secretdiffie_hellman) | [hkdf_extract](hash.pc.md#hkdf_extract)

### Curve25519Public.from_bytes

```
function Curve25519Public.from_bytes(bytes: byte_array[32])
    -> Curve25519Public:
  -> Curve25519Public wrapping PublicKey from bytes
```

### Curve25519Public.to_bytes

```
function Curve25519Public.to_bytes(self) -> byte_array[32]:
  -> self.inner as bytes
```

### Curve25519Public.as_bytes

```
function Curve25519Public.as_bytes(self) -> reference to byte_array[32]:
  -> reference to self.inner bytes
```

### XDR conversions

```
"Bidirectional conversion between native and XDR Curve25519 types."
"Curve25519Public <-> xdr::Curve25519Public (via .key field)"
"Curve25519Secret <-> xdr::Curve25519Secret (via .key field)"
```

### clear_curve25519_keys

```
function clear_curve25519_keys(
    public: mutable Curve25519Public,
    secret: mutable Curve25519Secret):
  "Security measure to clear key material from memory."
  "The previous Curve25519Secret is zeroized on drop."
  secret = Curve25519Secret from zeroed bytes
  public = Curve25519Public from zeroed bytes
```

## Summary

| Metric        | Source | Pseudocode |
|---------------|--------|------------|
| Lines (logic) | 95     | 58         |
| Functions     | 10     | 10         |
